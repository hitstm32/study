## 1.原子操作

原子操作不会并发的访问同一个变量，所以不会引起竞争。**大多数体系结构会提供支持原子操作的简单算术指令，某些体系结构缺乏原子操作指令，但是也为单步执行提供了锁内存总线指令，确保了其他改变内存的操作不会同时发生**。
![[Pasted image 20240225182449.png]] 
计算机在读取一个字长的数据时本身就是原子操作，所以
![[Pasted image 20240225182958.png]] 
将原子变量转化为普通变量的操作本身就是原子的。（字长=计算机位数/8），原子操作与各种锁机制来说，开销更小，对高速缓存行的影响也更小。

### 64位原子操作

考虑到移植性，atomic_t在64位系统中依然为32位，若要使用64位，则要用atomic64_t

## 2.自旋锁

Linux的自旋锁不可递归，所以如果想去获得一个已经持有的锁，就会造成死锁。自旋锁可以用在中断处理程序中，因为如果在这里用信号量会导致睡眠。**linux中断中无法睡眠，是因为中断不属于任何进程，它自己也没有task_struct，无法被调度器调度，也无法进入“睡眠”或“运行”状态**。在中断中获取锁之前，要先禁用本地中断（本处理器中断），不然可能在获取锁之后又再次被该中断抢占，再次获取锁，然而这时锁已经被该中断持有，所以就会死锁。不需要禁止别的处理器的中断是因为别的处理器中断不会影响本处理器的中断，不会导致本处理器中断得不到执行，所以本处理器就可以正常释放锁。![[Pasted image 20240225191124.png]]

## 3. 读-写自旋锁

应用于生产者-消费者模式，这种自旋锁只能被一个写任务持有，而可以被多个读任务持有，大概就是读的时候不能写，写的时候不能读，一旦写完，所有读持有者都会得到运行。![[Pasted image 20240225233343.png]] 这种锁是照顾读者的，如果有一大堆读者，那他们会高频获得读锁，导致写操作一直被拒绝，知道所有读锁都被释放，才能获得写的机会。

## 4.信号量

![[Pasted image 20240225235414.png]]

### 读-写信号量

与读写自旋锁类似，只有唯一的写者可以获得锁，有多个读者可以获得锁，读者睡眠只可能是因为写信号量被持有。与信号量类似，读写信号量也提供`down_read_trylock()和down_write_trylock()`

## 互斥体

![[Pasted image 20240226191311.png]]

- 互斥体的计数永远是1
    
- 必须在同一个上下文中锁定和解锁一个mutex，所以不适合内合同用户空间复杂的同步场景
    
- 递归上锁解锁不允许
    
- 持有一个mutex时，进程不能退出
    
- 不能在中断或者下半部使用，即使是mutex_trylock也不行
    
- 只能通过内核API管理，不可拷贝，手动初始化，重复初始化 通过**调试模式**（打开内核配置选项CONFIG_DEBUG_MUTEXES），就可以检查这些行为。 互斥体的效率高于信号量，所以能用互斥体就用互斥体
    

### 何时使用自旋锁和互斥体？

![[Pasted image 20240226191823.png]]

## 7. 完成变量

内核中一个任务需要发出信号通知另一个任务发生了某个特定时间，就可以利用完成变量。这时两个任务同步的简单办法。一个任务可以在完成变量上等待另一个任务完成，跟信号量思想上是一样的。但是比信号量用起来简单。适合简单的任务通知![[Pasted image 20240227123357.png]]

## 顺序锁

用来判断读的时候有没有被写入，导致不一致现象![[Pasted image 20240227125622.png]] 顺序锁和读写自旋锁区别在顺序锁倾向于写者，读者不断尝试，直到读到没被篡改的数据为止。顺序锁适合以下场景：

- 数据读者很多
    
- 数据写者很少
    
- 希望写优先于读，不允许读者让写者饥饿
    
- 数据很简单 **使用顺序锁的典型是`jeffies`，某个定时器会定期更新该变量，然而读者众多，不能让读操作影响写入操作，可以让读操作让步一下。这时就很适合顺序锁。**
    

## 禁止抢占

preempt_enable();  
preempt_disable();

## 顺序和屏障

a=1;  
b=2;

有些处理器会在取指运行时改变以上顺序，因为这两个变量看似毫不相干，但是如果有两个线程，，另一个线程需要读a和b，就可能读到a或者b未赋值前的值，所以需要确保程序执行的顺序，这种技术叫做“内存屏障”![[Pasted image 20240227203251.png]] **volatile是防止C编译器缓存数据，这样每次访问寄存器时，处理器都会在总线上生成对应的传输时序，而不是读写缓存**对于大多数数据，如果定义为volatile，那么他们的内存空间将会`non-cacheable`，就不需要维护内存访问顺序，然而这样效率会大大降低。所以才需要内存屏障指令，来确保之前的内存访问已经完成后再执行下一个操作。![[Pasted image 20240227203719.png]] DMB指令会暂时停止指令流水线，确保之前的内存操作已经完成。

## 为什么会发生内存排序？（TODO）

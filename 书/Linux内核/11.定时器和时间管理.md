内核的时间来自于硬件定时器，该定时器以固定频率触发中断来更新系统时间。在定时器中断中，不仅要维护系统时钟，还要调用一些周期性的任务，这些任务可能多次中断才运行一次。
## 11.2节拍率
系统的定时器频率通过静态预处理定义（HZ），系统启动时按照HZ进行硬件配置。在X86体系中，HZ一般为100，也就是中断频率为100HZ，但是其它体系有250和1000的。
![[Pasted image 20240302134110.png]]
### 11.2.1理想的HZ值
高HZ的好处：
* 更高的时钟驱动事件解析度
* 更高的时间驱动事件的准确度
	内核可能在任意时间初始化某个定时器，定时器可能在未来任何时间超时。然而内核只能等时钟中断到来才能执行它，这就导致定时器响应带来了时间误差，平均误差为半个时钟周期。通过提高HZ值，可以降低这种误差。
* 依赖定时值执行的系统调用，比如POLL()和selsect()，能以更高的精度执行
	对poll和select超时精度的提高会给系统性能带来巨大好处，频繁使用以上两种系统调用的程序，往往在等待时钟中断上浪费大量时间。实际上定时器可能早就超时了，但是系统还没被中断调度响应。
## 11.3 jiffies
jiffies用来记录子系统启动以来的总节拍数，每次处理中断程序就会增加该变量的值，如果想得到系统实际运行时间，就需要`jiffies/HZ`.==实际上内核会给jiffies赋一个初值，引起变量不断溢出，由此捕捉bug，当找到实际jiffies后，再把这个偏差减去==（没懂）。
一般内核中把秒转为jiffies比较多，比如：
```c
unsigned long time_stamp = jiffies;
unsigned long next_tick = jiffies+1;
unsigned long later = jiffies+5*HZ; //设置五秒后的jiffies
unsigned long fraction = jiffies + HZ/10;
```
### 11.3.1jiffies内部表示
jiffies为unsigned long，因此在32位体系结构上为32位，在64位体系结构上为64位。32位的jiffies，在100HZ情况下，497天后会溢出。考虑到兼容性，所以依然使用unsigned long，但是用了些神奇思想。
```c
extern unsigned long volatile jiffies;
extern u64 jiffies_64;
jiffies = jiffies_64;
```
应用程序一般访问jiffies，而定时器中断维护的是jiffies_64。
### 11.3.2jiffies的回绕
```c
#define time_after(a,b)     \
    (typecheck(unsigned long, a) && \
     typecheck(unsigned long, b) && \
     ((long)((b) - (a)) < 0))
#define time_before(a,b)    time_after(b,a)

#define time_after_eq(a,b)  \
    (typecheck(unsigned long, a) && \
     typecheck(unsigned long, b) && \
     ((long)((a) - (b)) >= 0))
#define time_before_eq(a,b) time_after_eq(b,a)
```
jiffies只有32位，当计数到4294967295后会变到0，这会导致bug，内核中提供了一些宏来防止卷绕。原理也不复杂，就是利用了`250-255<0，250-1<0`的原理，相当于先减，再转为有符号数，这样就能防止在255->0的过程中发生卷绕，因为绕回0之后符号没变。**但是，时差不能太大，因为当设定的时差太大，一开始就会直接输出1，time-jiffies要小于4294967295/2**，一般来说，我们不会延迟那么长时间，所以短时间延迟可以放心使用这几个宏。
## 11.4硬时钟和定时器
### 11.4.1RTC
系统启动时内核会读取RTC来初始化墙上时钟xtime。
### 11.4.2系统定时器
系统中断时钟，用来触发系统定时器中断，以更新jiffies和进行一些任务。
## 11.5时钟中断处理程序
```c
/*

 * Periodic tick

 */

static void tick_periodic(int cpu)

{
    if (tick_do_timer_cpu == cpu) {
        write_seqlock(&jiffies_lock);

        /* Keep track of the next tick event */
        tick_next_period = ktime_add(tick_next_period, tick_period);
        do_timer(1);
        write_sequnlock(&jiffies_lock);
        update_wall_time();
    }

    update_process_times(user_mode(get_irq_regs()));
    profile_tick(CPU_PROFILING);
}
```
对jiffies的更新位于do_timer(1);
## 11.7 定时器（软）
```c
struct timer_list {
	/*
	 * All fields that change during normal runtime grouped to the
	 * same cacheline
	 */
	struct hlist_node	entry;//定时器链表节点
	unsigned long		expires; //以jiffies为单位的定时值
	void			(*function)(unsigned long); //定时器处理函数
	unsigned long		data;//传给处理函数的参数
	u32			flags;//定时器内部值，不要管
};
```
使用过程：
* 定义
	* `struct timer_list my_timer`
* 初始化内部值
	* `init_timer(&my_timer)`
* 填充内部值
	* my_timer.expires = jiffies + delay;
	* my_timer.data=0;
	* my_timer.function = my_function;
* 激活定时器
	* add_timer(&my_timer);
* 改变超时时间
	* mod_timer(&my_timer, jiffies+new_delay);
* 删除定时器
	* del_timer(&my_timer);
## 11.8 延迟
### 11.8.1忙等待
```c
unsigned long timeout = jiffies+HZ/10; //等待0.1s
while(time_before(jiffies, timeout))
;
```
该方法最简单，但是会在原地旋转，低效。更好的办法是在等待过程中先去干别的事，改进如下：
```c
unsigned long timeout = jiffies+HZ/10; //等待0.1s
while(time_before(jiffies, timeout))
	cond_resched();
```
`cond_resched()`这个函数将系统中 优先级更高的程序调度执行。由于需要涉及调度，这个函数不能在中断上下文中被调用，只能在进程上下文中被调用。
### 11.8.2短延迟
基于jiffies的办法，时间粒度只能到1/HZ秒级别，内核提供了ms,us,ns。其中ms函数由us函数实现，而us函数通过循环来实现，究竟需要多少次循环，取决于处理器的BogoMIPS值。![[Pasted image 20240303232021.png]]
udelay只应当在小延迟使用，因为可能溢出。
### 11.8.3 schedule_timeout()
让任务睡眠到指定延迟时间耗尽后再执行，但是也不能保证准确，因为HZ。这个函数会把任务推入可中断睡眠队列，也可以把人物设置为TASK_UNINTERRUPTIBLE，不让任务被中断唤醒。但是必须设置，否则任务不会被睡眠。该函数也只能在进程上下文被调用。这个函数利用定时器实现，把唤醒睡眠队列的函数放入了中断处理函数中，设定好定时器后直接调用schedule()，同时**由于该任务被标识为`TASK_INTERRUPTIBLE或TASK_UNINTERRUPTIBLE`，所以调度程序不会再选择该任务投入运行，而是调度其他任务。**
```c
sleeping_task = current;
set_current_state(TASK_INTERRUPTIBLE);
schedule();
func1();
/* Rest of the code ... */
```

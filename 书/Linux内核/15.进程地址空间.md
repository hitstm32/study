linux操作系统采用虚拟内存技术，系统中所有进程之间以虚拟的方式共享内存，对一个进程而言，它会感觉自己可以访问整个物理内存，甚至，它会觉得自己拥有的内存远远大于物理内存.....
## 15.1地址空间
采用了虚拟内存的操作系统，每个进程都有自己独立的32位或者64位平坦的（flat）地址空间，该空间是连续的。一个进程与另一个进程的地址空间即使有相同的物理地址，它们也能互不相干。
尽管一个进程可以寻址4G的虚拟内存，但是不代表它有权访问所有虚拟内存，地址空间中，只有一部分能被进程访问，比如08048000-0804c000，这些可被访问的合法地址空间被称为**内存区域**，通过内核，进程可以给自己的地址空间动态添加或者减少内存区域。
进程只能访问有效内存区域的内存，每个内存区域也有相关权限（可读，可写，可执行属性），如果一个进程访问了不在有效范围内的内存区域，或者以不正确的方式访问了，那内核就会把进程终止，并返回**段错误**。
内存区域中可以包含：
* 可执行文件的代码指令：代码段
* 已初始化的全局变量：数据段
* 未初始化的（会被自动初始化为0）全局变量：BSS段
* 用于进程用户空间栈的零页的内存映射
* c库或者动态链接库的代码段，数据段，bss
* 任何内存映射文件
* 任何共享neicunduan任何匿名的内存映射，比如malloc分配的(glibc中用mmap和brk实现)
执行的进程中，每个不同的内存片段都对应一个独立的内存区域，例如栈和bss等都位于不同的内存区域。
## 15.2内存描述符
内核使用内存描述符表示进程的地址空间，包含了进程地址空间全部信息：
![[Pasted image 20240314233252.png]]
![[Pasted image 20240314233301.png]]
## [797. 所有可能的路径](https://leetcode.cn/problems/all-paths-from-source-to-target/)
图遍历，思路不复杂，就是每进入一个节点，就压栈，出节点时就出栈，这样当找到目标节点时，栈里村的就是所需路径了。
```cpp
class Solution {
public:
    vector<vector<int>> res;
    void traverse(vector<vector<int>>& graph, int s, vector<int> &path){
        int n = graph.size();
        path.push_back(s);

        if(s==n-1){
            res.push_back(path);
        }
        
        for(auto i:graph[s]){
            traverse(graph, i, path);
        }
        path.pop_back();

    }

    vector<vector<int>> allPathsSourceTarget(vector<vector<int>>& graph) {
        vector<int> path;
        traverse(graph, 0, path);
        return res;
    }
};
```

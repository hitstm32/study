假设一个队列通过链表实现，有插入函数和删除函数可以操纵这个链表，由于插入和删除链表都不是原子的，所以当一个线程在插入，而另一个线程想读取链表时，就会导致出错。解决方法就是加锁。**锁是自愿的，非强制的**。锁本身不存在竞争关系，因为锁本身是原子变量实现的。

# 造成并发执行的原因

- 中断
    
- 软中断和tasklet
    
- 内核抢占
    
- 睡眠（也是被调度）
    
- 对称多处理器 其实总结起来，就是因为中断和对称多处理器。在临界区中睡眠是最大的竞争隐患，因为这大大提高了临界区时间，并且把竞争者的临界区访问几率大大提高了。
    

# 加锁

加锁简单，但是辨别哪里需要加锁难。首先要知道我们要保护什么。执行线程局部的数据仅仅被自己访问，所以不用被保护。比如：

- 局部自动变量（包括动态分配的数据结构，其存在于堆栈中，无需保护）
    
- 数据被特定的进程访问，也不用被保护 大多数内核的数据结构都需要加锁，如果有其他执行线程可以访问这些数据，那就需要给数据加锁。 需要考虑：
    
- 数据是不是全局的？除了当前进程，还有其他线程能访问吗？
    
- 数据会不会在进程上下文或者或者中断上下文中被共享，会不会被两个中断处理程序共享？
    
- 进程在访问数据时会不会被抢占且被新调度的程序访问？
    
- 如何防止数据失控？
    
- 如果这个函数在另一个处理器上被调度会发生什么？
    

## 死锁

### 自死锁

尝试获得自己已经获得的锁，自己将永远没机会释放锁。

### ABBA死锁
![[Pasted image 20240301094419.png]]

## 如何写出不死锁的代码？

- 嵌套锁时必须约定好使用相同的顺序加锁，防止ABBA死锁
    
- 确定被锁代码一定会结束
    
- 不重复请求同一个锁
    
- 简化锁逻辑，使用简单的锁 第一点最重要，比如有三个锁，几个函数都需要获得这三个锁，那么他们必须以相同顺序获得这三把锁，否则极有可能发生死锁
    

## 性能

锁被长时间占用就会导致争用。如果锁的粒度过大，比如一个子系统结构体用一把锁，就会导致频繁的争用，各个程序想访问结构体中的任何不安全成员都得获得同一把锁，所以就导致了性能的降低。现在Linux内核中已经把加锁的粒度减小，一把锁只保护很小一块数据，这样来减少锁被争用的可能。但是一味减小粒度也不是好事，因为会提高复杂度，增大开销。 一个例子就是Linux的调度队列，调度队列如果只有一把锁，在大型机上就会被每个处理器争用，降低了效率。
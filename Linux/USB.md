USB设备被发现的过程是通过USB D+或者D-上的电平跳变，USB host端D+D-有15K下拉电阻，USB device内部D+或者D-有1.5k上拉电阻，当USB设备插入，D+或者D-会被拉高，由此host端实现了设备的检测。D+拉高为全速设备（12Mbps），全拉高为低速设备，高速设备的硬件和全速设备一样，但是软件上加以区分，识别到全速设备后先复位，然后通过协议询问是否支持高速，如果支持，则转换到高速模式（480M）
## USB状态切换图
![[Pasted image 20240617163851.png]]
![[Pasted image 20240617165927.png]]
## USB传输逻辑：
![[Pasted image 20240617171256.png]]
IDLE->SOP->同步脉冲串->数据负载->EOP->IDLE
**传输使用反相不归零码(NRZI)+位填充**
## 软件层面数据传输：
### 事务：
![[Pasted image 20240617171525.png]]
如果要访问某个设备，肯定要确定设备的地址和端点。所有数据传输都是host发起，还需要确定数据传输方向。
![[Pasted image 20240617171756.png]]
PID中含有方向、包类型。
![[Pasted image 20240617172119.png]]
PID域有8位组成，实际上有效位数为4，分为4大类包
![[Pasted image 20240617172324.png]]
这里的输入和输出都是相对host。
地址有7位，端点4位
![[Pasted image 20240617172625.png]]
![[Pasted image 20240617172629.png]]

**如果想发数据，就要先发个令牌包(token phase)，然后再发数据包（data phase），数据包里才包含数据本身。收到数据后，dev可以回复握手(ACK)包(hand phase)，这三种包组成了一种<span style="color:#c00000">事务</span>，事务是一次传输的完整流程**
**如果想读数据，先发起读令牌包，然后设备端发送数据包，最后host发送握手包完成传输**
事务由包组成，包由域组成，域由位组成。

### 传输：
![[Pasted image 20240617174558.png]]
* 批量传输：可靠，非实时
* 中断传输：可靠，实时
* 实时传输：不可靠，实时
所有传输都是由host发起，即使dev有数据，也不能主动发给host，这就导致所谓的“中断传输”并不是真正的中断，只是周期性的发起传输，尽量做到实时。
![[Pasted image 20240617182844.png]]
一个bulk， int， iso分别由1个事务实现。一个control传输由多个事务实现。
#### 批量传输（事务）bulk
![[Pasted image 20240617183216.png]]
如果要进行大量传输，直接简单重复以上过程即可，只不过发data包时要不断切换PID中的DATA0和DATA1。
#### 中断传输
![[Pasted image 20240617184704.png]]
跟批量传输区别不大，少了ping和一个握手pid。
#### iso（实时传输）
![[Pasted image 20240617185122.png]]
不用发握手包了，更快。
#### 控制传输（Transfer）
![[Pasted image 20240617185333.png]]
控制传输由多个事务组成，首先发起一个setup事务，然后再发起data事务，然后状态事务。
* 建立事务：由三个包组成：
	* 设置令牌包：通知设备要开始一个控制传输，无方向。
	* 数据包：数据包里包含收发双方约定好的格式化数据，例如收还是发之类的
	* 握手包：响应
* 
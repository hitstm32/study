![[Pasted image 20240828104700.png]]
该层用来实现硬件IIC控制器的抽象，和gpio模拟iic的实现。adapter driver为芯片硬件iic驱动，需要BSP工程师实现。软件iic驱动`i2c-gpio.c`内核自带，也就是说，如果要给一个新芯片适配驱动，可以先用i2c-gpio来进行软件通信尝试。然后再实现adapter driver来实现片内iic控制器驱动。

# Adapter Driver
下面分析imx的i2c adapter驱动
```c
#imx6ul.dtsi:
/ {
	soc {
		i2c1: i2c@21a0000 {
			#address-cells = <1>;
			#size-cells = <0>;
			compatible = "fsl,imx6ul-i2c", "fsl,imx21-i2c";
			reg = <0x021a0000 0x4000>;
			interrupts = <GIC_SPI 36 IRQ_TYPE_LEVEL_HIGH>;
			clocks = <&clks IMX6UL_CLK_I2C1>;
			status = "okay";
		};
		i2c2: i2c@21a4000 {
			#address-cells = <1>;
			#size-cells = <0>;
			compatible = "fsl,imx6ul-i2c", "fsl,imx21-i2c";
			reg = <0x021a4000 0x4000>;
			interrupts = <GIC_SPI 37 IRQ_TYPE_LEVEL_HIGH>;
			clocks = <&clks IMX6UL_CLK_I2C2>;
			status = "okay";
		};
		i2c3: i2c@21a8000 {
			#address-cells = <1>;
			#size-cells = <0>;
			compatible = "fsl,imx6ul-i2c", "fsl,imx21-i2c";
			reg = <0x021a8000 0x4000>;
			interrupts = <GIC_SPI 38 IRQ_TYPE_LEVEL_HIGH>;
			clocks = <&clks IMX6UL_CLK_I2C3>;
			status = "disable";
		};
		i2c4: i2c@21f8000 {
			#address-cells = <1>;
			#size-cells = <0>;
			compatible = "fsl,imx6ul-i2c", "fsl,imx21-i2c";
			reg = <0x021f8000 0x4000>;
			interrupts = <GIC_SPI 35 IRQ_TYPE_LEVEL_HIGH>;
			clocks = <&clks IMX6UL_CLK_I2C4>;
			status = "disable";
		};
	}
}
```
imx的i2c驱动位于`i2c-imx中`，通过initcall机制，在内核初始化时直接调用该函数，注册platform_driver。
```c
static int __init i2c_adap_imx_init(void)
{
	return platform_driver_register(&i2c_imx_driver);
}
subsys_initcall(i2c_adap_imx_init);
```
of_match_table：
```c
static const struct of_device_id i2c_imx_dt_ids[] = {
	{ .compatible = "fsl,imx1-i2c", .data = &imx1_i2c_hwdata, },
	{ .compatible = "fsl,imx21-i2c", .data = &imx21_i2c_hwdata, },
	{ .compatible = "fsl,vf610-i2c", .data = &vf610_i2c_hwdata, },
	{ /* sentinel */ }
};
MODULE_DEVICE_TABLE(of, i2c_imx_dt_ids);
```
可见，上面的设备树生成4个platform_device中，有2个status为okay，与platform_driver匹配后将会产生2个i2c设备节点。
![[Pasted image 20240903151801.png]]

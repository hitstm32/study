以raw的形式读写磁盘，不使用“文件”的形式。
![[Pasted image 20240330120810.png]]
移动磁头到相应磁道，然后随着盘片旋转，对指定位置进行数据，读入内存。
![[Pasted image 20240330121109.png]]
由于大部分大容量硬盘都是堆叠盘，有多个堆叠的磁头和盘片，由多个盘片上相同位置的扇区叫柱面。最终就是要控制这几个参数。
![[Pasted image 20240330121310.png]]
控制这些参数用的是out指令，通过out指令把这些参数写向磁盘。这样就可以利用生磁盘了。这时没有文件的概念。
# 第一层抽象：盘块号
![[Pasted image 20240330121459.png]]
最简单的想法是直接把硬盘抽象成一个个盘块，用户通过盘块号读写磁盘，驱动通过盘块号转换成chs坐标，这样就可以向用户隐藏chs坐标。
## 磁盘访问时间分析：
![[Pasted image 20240330121849.png]]
可见，主要时间在寻道上。通过磁盘号读写磁盘时，应该实现相邻的盘块号的磁道也相邻，这样才能尽量减少寻道时间。所以相邻盘块号应该在同一个磁道上，至少也应当在同一个柱面上，当一个柱面排完了，就只能往下一个柱面排。
所以盘块号计算可以这么算：
![[Pasted image 20240330122622.png]]
可见，应当每次多连续读一些，这样可以把传输带宽用起来，尽量少浪费在寻道上。所以把一个盘块多分配几个连续的扇区，这样就可以把盘块放大，一次多读写一些，相当于用空间的浪费换取时间效率的提升。
实际从block号计算CHS的linux0.11代码如下：
![[Pasted image 20240330123555.png]]
可见linux0.11的盘块包含两个扇区。
# 第二层抽象：多进程
![[Pasted image 20240330124142.png]]
磁盘做完上一次操作后，会触发中断告知计算机，然后计算机把下一个队列中的请求载入磁盘。这一层抽象的核心就是请求的调度算法，如何让磁盘驱动处理队列更高效，让平均访问延迟尽可能小，寻道时间尽可能少。
### 从fcfs开始（谁先来谁先服务）
![[Pasted image 20240330124934.png]]
可见，这种最简单的办法，寻道次数太多，移动距离太长，效率低下。
### SSTF磁盘调度
从当前开始，谁距离最近就先处理谁，短寻道优先。
![[Pasted image 20240330125014.png]]
当处理的请求集中于中部，但是有时有比较远的请求时，就会出现较远请求的处理延迟，导致饥饿问题。
### scan扫描调度算法
在往一个方向走时，会走到头，并且顺便处理中间请求。当走到头之后，在返回头来去向另一个方向处理。实际上就是SSTF结合了**中途不折回**。
![[Pasted image 20240330130131.png]]
### c-scan磁盘调度（电梯算法）
scan+直接复位磁头，这样两端的请求都可以很快处理。
![[Pasted image 20240330130309.png]]
![[Pasted image 20240330130343.png]]
所以多进程磁盘调度算法的核心就是将请求按照电梯算法加入到请求队列中。
![[Pasted image 20240330131309.png]]
这一段就是在形成一个电梯有序队列。

# 生磁盘使用总过程：
![[Pasted image 20240330131835.png]]


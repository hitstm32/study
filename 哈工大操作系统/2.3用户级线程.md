**在用户级线程中，线程切换函数是用户程序，而不是内核程序**，这是不是协程？是的。
![[Pasted image 20240404143744.png]]
执行的指令发生变化，但是内存映射不发生变化。线程比进程轻巧，因为切换起来更简单，开销小。因为一个进程中的多个线程公用进程地址空间，可以不用切内存。
![[Pasted image 20240404144157.png]]
![[Pasted image 20240404144613.png]]
获取到数据后，使用yiled函数主动放弃运行权力，让另一个线程得到执行，使得图片得以显示。
![[Pasted image 20240404145513.png]]
如果两个线程用一个调用栈，那函数返回时可能回跑回另一个线程，这样就导致错乱（<span style="color:#0070c0">yield</span>()返回到404）。所以需要两个栈。每个线程拥有自己的栈。
![[Pasted image 20240404145720.png]]
两个线程都拥有自己的栈，在线程切换时需要进行栈的切换。所以每次调用yield需要切栈的过程，栈指针存放在TCB里：
![[Pasted image 20240404145922.png]]
其实不需要jmp，因为PC已经被压入栈里，所以等程序返回直接弹栈即可。
![[Pasted image 20240404150241.png]]
所以到目前为止，线程需要三样东西：TCB、栈、线程切换PC压栈。
![[Pasted image 20240404150925.png]]
所以创立线程时，需要建立起TCB，分配栈空间，并把栈指针存入tcb中。
## 用户级线程的特性
用户级线程位于进程内部，属于某个进程，如果进程中某个线程休眠了，但是其它线程还想运行。可这时**进程调度器**根本不知道**线程**。这就会导致，进程直接休眠，这个进程中所有线程都得不到运行。也就是说用户级线程无法直接被进程调度器管理。
![[Pasted image 20240404151708.png]]
以上问题可以由**核心级线程**解决。
![[Pasted image 20240404152050.png]]
核心级线程对于调度器是可见的，可以直接被调度器调度。核心级线程直接用schedule()进行切换。所以不会有上面一个线程休眠所有线程休眠的情况。所以核心级线程更像进程？
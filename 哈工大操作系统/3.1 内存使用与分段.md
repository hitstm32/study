# 重定位
程序要放入某个进程运行时，编译好的程序是从0地址开始运行，但是最终机器码放到内存中时，却不能放到0地址处（因为0地址附近是内核），所以程序中的逻辑地址就必须转换为物理地址，这个转换的过程，就被称作重定位。重定位实际就是把逻辑地址+了一个基址，使之成为物理地址。
## 什么时候重定位？
如果在**编译时**重定位，那还得知道将来要放到哪个地址上去。这样不够灵活，但是效率高
所以应该在**载入时**重定位，载入的时候对地址进行操作即可。灵活，但是载入的时候效率低。
只在载入时重定位还是不够，因为很多时候载入后还得再移动：
### 交换（swap）
![[Pasted image 20240321215656.png]]
如果某个进程要长时间睡眠，那就把它放到磁盘里暂存，然后继续运行不睡眠的程序。这就导致程序在运行过程中，可能被换入换出，程序运行地址发生改变，从而导致载入重定位失效。
所以最好的解决办法就是**运行时**重定位，也叫做**地址翻译**。
![[Pasted image 20240321220436.png]]
运行时会实时进行地址翻译，会把逻辑地址加一个基地址。基地址存放在**PCB**中，随着进程被换入换出，基地址会发生变化，经过翻译后的地址即可以正常跳转。翻译的工作由**MMU**进行。
# 运行时重定位过程总结：
* 编译代码，保存在磁盘中
* 创建进程，创建PCB
* 内存中找一段空闲地址，把基址赋给PCB，把磁盘中的程序装载到基址开始处
* 进程切换时，将该进程PCB中的基址放入**基址寄存器**
* PC指针指向基址处，开始运行
* MMU对跳转地址进行翻译，实现运行时重定位
# 内存分段
程序由若干部分（段）构成，各个段用途不同。且各个段有自己的0地址。![[Pasted image 20240321225700.png]]
分别管理的原因：操作变量段的时候，不会影响到主程序段（只读）。
但是如果程序分段放入内存，每个段不一定放在什么地方，那么就需要分别记录每个段的基地址，段的基地址保存在进程段表（LDT）中，并把LDT表存入PCB，以便重定位时使用。
https://zhuanlan.zhihu.com/p/612404856
在8086出现以前，CPU都工作在**实模式**下，没有段的概念，成需要在计算机上运行，必须采用**静态重定位**方式，将内存地址写死在代码中。这导致程序装入内存后位置就不可动了，操作系统无法对程序进行再次重定位。
# 静态重定位：
没有段概念前，程序直接访问物理地址，编译和链接阶段，编译器无法确定程序将被装入的物理地址，所以产生的机器码里的地址都以0x00000为基准，地址为相对地址（逻辑地址）。当程序装入内存时，操作系统的装入程序模块会对目标程序中的地址相关的机器指令进行修改，将逻辑地址转为物理地址，这就是**静态重定位**。
弊端：程序首次装入内存后就不能动了，操作系统无法完成内存的回收与分配，导致内存空间产生大量碎片，让新的程序无法装入，例如如下例子，即使新程序才100KB，剩余空间由160KB，也无法装入，因为程序的载入导致内存碎片化了，而程序无法挪动，不能消除这些碎片。所以intel才发明了**段**来实现动态重定位。

# 动态重定位
动态重定位不需要在装入阶段进行指令修改，而是执行阶段CPU访问内存时进行逻辑地址到物理地址的转换。动态重定位不需要软件支持，而需要CPU支持。引入**段基址寄存器**保存程序被分配的起始物理地址。编译链接生成的逻辑地址作为**段内偏移地址**。CPU运行时将段基址和偏移相加得到物理地址。
在分段基础上，还把每个程序内部所占内存分了段，这样就可以把程序打散成更小的块分布在内存里，减少内存碎片。一般分为**代码段cs，数据段ds，栈段ss，BSS段，堆段**，还提供了es，fs，gs三个附加的段寄存器，可以作为自定义的段或者BSS之类的段来使用。
进程必须在内核中，实际上切换**用户级线程**就是切换**内核级线程**的重要组成部分。
![[Pasted image 20240404152838.png]]
只有多核心线程，才能充分利用多核，因为多核只有一个mmu，如果是多进程，那进行进程切换时，需要切换内存映射。但是利用核心线程，就可以实现不用切换内存映射，大大减小了时间开销，实现了高CPU利用率。

## 内核级线程和用户级线程实现区别
内核级线程利用系统调用`ThreadCreate`创建，内核管理TCB，内核负责切换线程。但是内核线程执行的代码又在用户空间，还要有函数调用。所以一个内核线程需要**两个**栈，一个用户栈，一个内核栈。
![[Pasted image 20240404160959.png]]
一旦通过中断陷入内核，就进入了内核栈，内核栈的主要工作就是把用户态的信息存储下来，例如用户栈指针，用户PC等等。当iret时，则弹出内核栈，返回到用户栈，恢复之前的运行。
![[Pasted image 20240404161559.png]]
例如调用`read()`系统调用：
![[Pasted image 20240404161804.png]]
触发中断后，会自动把用户态的各种信息存入内核栈，然后继续在内核态运行程序`sys_read`，该程序会读磁盘，引起阻塞，阻塞就会引起调度，CPU会从队列中取出待运行的线程，切换到下一个线程。
![[Pasted image 20240404162846.png]]
切换到下一个线程后，esp寄存器就被存入了线程T的esp，然后switch_to函数ret时，就会把资源从线程T的esp中弹出，切换到某个内核程序，ret到最后，实际上最后？？？？就是一段包含iret的代码，执行iret，就会把PC，SS：SP啥的也弹出，这样就回到了用户态。线程T的用户态应用程序得到执行。
## 内核级线程切换的五段论：
![[Pasted image 20240404164613.png]]

## ThreadCreate实现：
![[Pasted image 20240404164708.png]]
## 用户级线程，核心级线程对比
![[Pasted image 20240404170134.png]]

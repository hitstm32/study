![[Pasted image 20240415154343.png]]
这段代码最主要的地方在于通过15号中断获取扩展内存的大小，因为intelcpu最早只能管理1M内存，所以需要读入真实的物理内存大小。
下面的do_move，ds:si和es:di，cmp命令其实就是减命令,`cmp a, b == a-b`,减法会导致ZF和CF变化，当a=b，ZF=1，当a<b，CF=1，`jz`指令的意思是ZF=0就跳转，所以`cmp ax, #0x9000 jz end_move`合起来就是判断`ax==0x9000`的时候跳转。
movsw的意思是`movsw es:[di], ds:[si]`
## 进入保护模式
![[Pasted image 20240423094622.png]]
最后执行`jmpi 0, 8`按理说0给ip，8给cs，但是不应该这样，因为这样会跳到80地址处，位于system的一部分，会导致死机。我们需要的是跳到0地址处。按理说寻址位宽为20位，寻址1MB，但是这样肯定不够，需要寻址4GB，需要从16bit机切换到32bit模式（保护模式）工作。需要更改地址解释模式，cr0寄存器的最后一位决定了是实模式还是保护模式。
![[Pasted image 20240423095104.png]]
当切换到保护模式下之后，就会启用GDT，并且启用新的地址翻译机制来进行地址翻译，实现32位效果。
![[Pasted image 20240423095216.png]]
cs此时作为选择子，查找的是GDT里的内容，查出来之后再和ip相加，得到实际物理地址。GDT表的初始化在setup中已经完成了。如果启用了保护模式，中断也会从IDT中查表执行。
![[Pasted image 20240423095513.png]]
![[Pasted image 20240423095853.png]]
从GDT表项中，查找出相应的32位段基址，再和IP相加（这些操作由硬件完成）。
然后跳到了SYSTEM中执行。
![[Pasted image 20240423101131.png]]
head.s是进入system执行的第一段源码，位于system的头部。
![[Pasted image 20240423101214.png]]
真正初始化了GDT、IDT表，之前的ax都变成了eax(32位)，变成了AT&T汇编，源操作数在前，目标操作数在后，立即数编程$。
为什么head.s的汇编和前面不一样？
* as86汇编用来产生16位汇编代码的intel8086汇编
* GNU as汇编：产生32位代码，使用AT&T系统V语法
* 内嵌汇编，gcc编译x.c会产生中间结果as汇编文件x.s

在main.c中，有一堆初始化。
![[Pasted image 20240423104435.png]]
![[Pasted image 20240423104448.png]]
其中mem_init初始化了一个数组，保存了每4KB是否被使用，并给他们置零，表示都还未被使用。
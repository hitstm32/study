进程由两部分组成：资源和执行序列（内核级线程）。资源就是内存那部分。一个操作系统可以不支持内核级线程，但是必须支持进程。
线程的切换主要是**栈**的切换。
![[Pasted image 20240408093022.png]]
系统调用会引起中断，进入内核，这就是内核线程切换的第一段。对于系统调用函数，首先会将系统调用号写入eax，然后执行INT 0x80，触发软中断，进入中断处理程序，读取eax。这样就可以执行对应的系统调用程序。当进入80中断，CPU会把SS：SP，EFLAGS（存储进位标志啥的）压入内核栈，下一条指令作为返回地址也压入内核栈。
![[Pasted image 20240408094617.png]]
进入中断处理函数后，在内核栈中压入用户态中的段内容。然后调用sysfork函数，内核栈中压入返回地址，然后执行fork相关操作。sysfork会导致进程state被改变（比如睡眠），在sysfork中，会包含一段汇编，这段汇编会判断PCB中的state是否为非运行态，如果非运行态，就运行reschedule（<span style="color:#c00000">为什么不用call?</span>）,然后会执行schedule，运行下一个能运行的线程。还会判断线程的时间片是否为0，如果为0，也切换。<span style="color:#00b050">schedule引发的就是中间内核栈的切换，即第三段。</span>
![[Pasted image 20240408095816.png]]
![[Pasted image 20240408101328.png]]
中断返回就是一堆pop，把之前push进的东西都pop，返回用户空间
接下来讲schedule是如何切换核心栈的。
## switch_to
schedule的实现，切换五段中间三段，实现PCB和内核栈的切换。
从直观上来猜测，switch_to的任务应该是切换内核栈，但是实际上并不是直接切换内核栈，而是切换TSS(任务结构段)。这种方法由一条CPU指令实现，实现起来很容易，但是并不是一种高效的方法，因为单条指令完成的操作却很复杂，无法充分利用指令流水线，导致该指令效率低下，所以实际linux用的都是汇编切换内核栈。
![[Pasted image 20240408104138.png]]
linux0.11用的是TSS机制，使用TSS描述符存在全局GDT表里，每次Switch_to时根据传入的n，跳转到新的TSS。新的TSS里包含着新的任务的内容，包括各种寄存器。 
所以TSS跳转的完整过程：
* 把当前CPU寄存器存入当前TSS
* 根据传入的n，找到新的TSS
* 把新的TSS内容写入寄存器，里面也包含了esp啥的，所以段也被切换过来了
## ThreadCreate
![[Pasted image 20240408105426.png]]
通过栈传递了一堆寄存器，用来实现寄存器的复制。
![[Pasted image 20240408110133.png]]
可见分配了PCB，并且填写了TSS中的内核栈和用户栈等。然后用TSS初始化就可以了。
![[Pasted image 20240408110543.png]]
当fork执行执行完成后，父进程的state就被置非运行了，然后被阻塞，并且switch_to到子进程，TSS也跟着切到子进程，子进程就运行起来了。![[Pasted image 20240408110743.png]]
然后子进程会返回到INT 0x80的后一句指令，即
![[Pasted image 20240408110853.png]]
又因为子进程中eax被置0，所以res为0。所以调用fork时，一般会使用`if(!fork()){}`来运行子进程的程序。
那么，由于子进程拷贝了父进程几乎所有内容，那如何跑自己的代码？
## 子进程执行自己的代码
子进程可以使用exec来执行自己的代码，exec是个系统调用，通过该系统调用，我们想在中断返回时调用新的代码。
![[Pasted image 20240408111340.png]]
iret要做的工作就是把栈中存储的eip置给eip寄存器。
![[Pasted image 20240408111547.png]]
所以exec主要工作就是修改栈中保存的EIP，把EIP指向新的程序的开头即可。
![[Pasted image 20240408112255.png]]
lea指令可以取出目标变量的地址，这里实际就是找到了栈中EIP的地址，并存入eax，然后把eax压栈用来函数传参，调用_do_execve.EIP中其实就在+28处，这个返回地址就是INT 0x80下一条命令，也就是EIP。然后把新的程序入口地址存入eip，再把SP修改，修改段。程序是从磁盘读进来的，读进来之后会有个文件头，文件头就是代码的起始地址a_entry。
![[Pasted image 20240408112057.png]]


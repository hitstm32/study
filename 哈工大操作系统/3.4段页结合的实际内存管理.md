程序员希望用段，物理内存希望用页。 所以进行**先分段后分页**，应用程序载入时，在**虚拟地址**上开辟出各个段空间，这些段会被页表映射到物理内存上。虚拟内存就是段和页的中转。
![[Pasted image 20240326172710.png]]
## 段页同时存在时如何地址翻译
![[Pasted image 20240326174246.png]]
## 一个实际的段页内存管理
* 分配段，分配页，建立段表，建立页表
* 进程带弄内存使用的图谱
* 从进程fork中的内存分配开始

![[Pasted image 20240326175321.png]]
### fork的关键实现：
![[Pasted image 20240326175709.png]]
首先把虚拟内存的基址存入段表，可以看到这时候是linux0.11阶段的fork代码，还没有单个进程独占整个虚拟地址空间的概念，new_data_base是某个进程的存储空间在虚拟内存中的基址
![[Pasted image 20240326180035.png]]
![[Pasted image 20240326180407.png]]
这里由于子进程需要复制父进程的物理内存，所以子进程创建页表时要创建和父进程一样的页表项，并且设置为**只读**，这便是linux的**读时共享，写时复制**。这一操作大大提高了创建进程的时间。由虚拟地址转换为物理地址，由MMU硬件完成。只要把LDT表和页表弄好，MMU会自动进行转换。当对父进程继承来的内存地址进行写操作时，就会触发建立新页表项，开辟新的内存空间。
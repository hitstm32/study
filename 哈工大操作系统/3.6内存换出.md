当内存换入时，需要一个空闲页，然而并不总能获得空闲页，内存是有限的，需要有页的换出。那么到底选择哪一页换出？
* 最先想到的是FIFO，把最早换入的页换出，但是如果刚换入的页面马上要换出怎么办？
* 有无最优的淘汰方法？
* 使用LRU算法。
## FIFO页面置换
![[Pasted image 20240327103031.png]]
可见，D刚把A换出，然后A又需要换入，所以效率不高。效率的评价准则是**缺页次数**，FIFO法造成的缺页次数是**7次**。
## MIN页面置换
最优的方案，需要知道后面谁要换入，来确定现在换出谁，所以不可实现。
![[Pasted image 20240327104052.png]]
可见，MIN方法导致缺页次数是5次。

## LRU页面置换
通过历史去推测未来，选取最长一段时间没有使用的页来淘汰（最近最少使用），依赖程序的局部性。
![[Pasted image 20240327104635.png]]
## LRU算法的实现
### 时间戳方法
![[Pasted image 20240327104926.png]]
每个页维护一个时间戳，某个页换入时，更新时间戳。比较麻烦，每次换入需要查找然后修改，而且时间戳很有可能溢出。
所以LRU虽然简单，但是实际实现难做，所以对LRU还要进行近似
## LRU近似实现-将时间计数变为是和否（clock算法）
每个页添加一个引用位，每访问一次，硬件自动置位。选择淘汰位：循环扫描，是1清0，是零淘汰。是对LRU的近似，R=0直接指示了最近没有使用。
![[Pasted image 20240327110442.png]]
但是该方法的问题是如果缺页很少，每次都会直接访问内存中的页，那R就会都全变成1。
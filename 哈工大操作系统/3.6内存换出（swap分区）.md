当内存换入时，需要一个空闲页，然而并不总能获得空闲页，内存是有限的，需要有页的换出。那么到底选择哪一页换出？
* 最先想到的是FIFO，把最早换入的页换出，但是如果刚换入的页面马上要换出怎么办？
* 有无最优的淘汰方法？
* 使用LRU算法。
## FIFO页面置换
![[Pasted image 20240327103031.png]]
可见，D刚把A换出，然后A又需要换入，所以效率不高。效率的评价准则是**缺页次数**，FIFO法造成的缺页次数是**7次**。
## MIN页面置换
最优的方案，需要知道后面谁要换入，来确定现在换出谁，所以不可实现。
![[Pasted image 20240327104052.png]]
可见，MIN方法导致缺页次数是5次。

## LRU页面置换
通过历史去推测未来，选取最长一段时间没有使用的页来淘汰（最近最少使用），依赖程序的局部性。
![[Pasted image 20240327104635.png]]
## LRU算法的实现
### 时间戳方法
![[Pasted image 20240327104926.png]]
每个页维护一个时间戳，某个页换入时，更新时间戳。比较麻烦，每次换入需要查找然后修改，而且时间戳很有可能溢出。
所以LRU虽然简单，但是实际实现难做，所以对LRU还要进行近似
## LRU近似实现-将时间计数变为是和否（clock算法）
每个页添加一个引用位，每访问一次，硬件自动置位。选择淘汰位：每次进入缺页中断，循环扫描，是1清0，是零淘汰，并将页换入，把标志位置1。是对LRU的近似，R=0直接指示了最近没有使用。
![[Pasted image 20240327110442.png]]
但是该方法的问题是如果缺页很少，每次都会直接访问内存中的页，那R就会都全变成1。那缺页时就会把1全部换成0，然后再扫描一圈，从第一个换成0的页面开始换出。这样就变成每次按顺序换出了，退化成了fifo。根本原因在于，clock拟合LRU算法的根本是想表达**两次扫描之间没有被使用的页被换出，即“最近没有使用”**，但是由于缺页太少，两次扫描之间的距离就会太长，无法表达“**最近**最少使用”，导致平时指针几乎不移动，只有缺页时才会往后移动一位，所以就退化成了fifo。

原因是**记录了太长的历史信息**，需要改进。

### 改进CLOCK
再加一个指针扫描清除R位。实现**最近**。
![[Pasted image 20240328164857.png]]
定时清除指针放在时钟中断中，定时运行。

## 问题
该给进程分配多少页框？
如果分配的多，就会降低内存使用率，如果分配的少，就会导致频繁缺页，频繁磁盘IO，IO过程中CPU等待完成，会导致CPU占用率下降。
![[Pasted image 20240328165603.png]]
这一现象成为颠簸。
页框数量要覆盖住程序的**局部**，有很多办法例如**工作集**算法来实现。
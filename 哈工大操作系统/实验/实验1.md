### 实验内容

此次实验的基本内容是：

1. 阅读《Linux 内核完全注释》的第 6 章，对计算机和 Linux 0.11 的引导过程进行初步的了解；
2. 按照下面的要求改写 0.11 的引导程序 `bootsect.s`
3. 有兴趣同学可以做做进入保护模式前的设置程序 `setup.s`。

改写 `bootsect.s` 主要完成如下功能：

1. `bootsect.s` 能在屏幕上打印一段提示信息“XXX is booting...”，其中 XXX 是你给自己的操作系统起的名字，例如 LZJos、Sunix 等（可以上论坛上秀秀谁的 OS 名字最帅，也可以显示一个特色 logo，以表示自己操作系统的与众不同。）

改写 `setup.s` 主要完成如下功能：

1. `bootsect.s` 能完成 `setup.s` 的载入，并跳转到 `setup.s` 开始地址执行。而 `setup.s` 向屏幕输出一行"Now we are in SETUP"。
2. `setup.s` 能获取至少一个基本的硬件参数（如内存参数、显卡参数、硬盘参数等），将其存放在内存的特定地址，并输出到屏幕上。
3. setup.s 不再加载 Linux 内核，保持上述信息显示在屏幕上即可。



# bootsect.s
```c
! Print some inane message
	mov	ah,#0x03		! read cursor pos
	xor	bh,bh
	int	0x10
	
	mov	cx,#33
	mov	bx,#0x0007		! page 0, attribute 7 (normal)
	mov	bp,#msg1
	mov	ax,#0x1301		! write string, move cursor
	int	0x10



msg1:
	.byte 13,10
	.ascii "Hu os is booting..."
	.ascii "boot ok!"
	.byte 13,10,13,10
```


# setup.s

```c
! Get memory size (extended mem, kB)

	mov	ah,#0x88
	int	0x15
	mov	[2],ax
	mov dx, [2]
	call display_digital
halt:
 	j halt




display_digital:
	mov cx, #4
print_hex:
	rol	dx, #4
	mov al, dl
	and	al, #0x0f
	cmp	al, #0x9
	ja	ABC
	j	DIGITAL
ABC:
	sub al, #10
	add al, #65
	j	DISPLAY
DIGITAL:
	add al, #49

DISPLAY:
	mov ah, #0x0e
	int 0x10
	loop	print_hex
	ret
	
```
特别需要注意的是0x10中断的各种参数，不能遗漏参数，否则要么不显示，要么显示不正常
![[Pasted image 20240518042207.png]]
![[Pasted image 20240518042400.png]]
![[Pasted image 20240518042412.png]]

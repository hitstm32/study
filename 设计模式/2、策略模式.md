定义一系列算法，把他们一个个封装起来，并且使他们可以相互替换（变化）。该模式使算法可以独立于使用它的客户程序（稳定）而变化（扩展、子类化）。相当于<span style="color:#ffc000">遵循了开闭原则</span>。
**使用stranges模式可以尽量避免if else**
一段代码如下：
```cpp
enum TaxBase {
	CN_Tax,
	US_Tax,
	DE_Tax,
	FR_Tax       //更改
};

class SalesOrder{
    TaxBase tax;
public:
    double CalculateTax(){
        //...
        if (tax == CN_Tax){
            //CN***********
        }
        else if (tax == US_Tax){
            //US***********
        }
        else if (tax == DE_Tax){
            //DE***********
        }
		else if (tax == FR_Tax){  //更改
			//...
		}
        //....
     }
};
```
如果想给这段代码增加一个计算法国税务的功能，就需要修改算法内容，违反了开闭原则。

```cpp

class TaxStrategy{
public:
    virtual double Calculate(const Context& context)=0;
    virtual ~TaxStrategy(){}
};


class CNTax : public TaxStrategy{
public:
    virtual double Calculate(const Context& context){
        //***********
    }
};

class USTax : public TaxStrategy{
public:
    virtual double Calculate(const Context& context){
        //***********
    }
};

class DETax : public TaxStrategy{
public:
    virtual double Calculate(const Context& context){
        //***********
    }
};


//扩展
//*********************************
class FRTax : public TaxStrategy{
public:
	virtual double Calculate(const Context& context){
		//.........
	}
};


class SalesOrder{
private:
    TaxStrategy* strategy;

public:
    SalesOrder(StrategyFactory* strategyFactory){ //这里使用了工厂模式，还没讲
        this->strategy = strategyFactory->NewStrategy();
    }
    ~SalesOrder(){
        delete this->strategy;
    }

public double CalculateTax(){
        //...
    Context context();
        
    double val = strategy->Calculate(context); //多态调用
        //...
    }
    
};
```
策略模式的使用，使得salesorder是稳定的，在使用时只需要传入相应的策略，即可完成计算。
![[Pasted image 20240729211016.png]]
![[Pasted image 20240729211250.png]]

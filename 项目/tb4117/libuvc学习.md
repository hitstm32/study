由于需要对摄像头进行控制的同时获取图像，想出来如下办法：
* 直接使用v4l2子系统，对摄像头进行ioctl进行控制，通过控制摄像头的XU模块，进行厂家特有的控制
	* 对厂家摄像头固件有疑问，因为通过对SDK进行抓包，发现发送的包并不仅限于对XU的控制，还包括一些非UVC的内容。这导致只通过V4l2无法实现控制，因为V4L2的控制内容受摄像头固件限制，摄像头告诉V4L2能控，V4L2才能控制对应属性，但是目前来看，摄像头并没有把信息告诉V4L2。该方案放弃。
* 直接修改linux的uvc_driver.c，添加该摄像头信息，并在uvc_ctrl.c中的uvc_ctrl_init_device中添加该摄像头的初始化信息。在uvc_v4l2.c中添加一个ioctl，对应用层传来的usb控制传输进行转发。该方法可以实现功能，但是直接修改linux uvc驱动不太优雅，自己再写一个专用于该摄像头的驱动难度又过大。
* 在应用层通过libusb进行控制，通过v4l2进行视频流获取。
	* 尝试过，这个方案确实可以，但是libusb获取到控制权后，/dev/videox会消失（驱动被占用）。这就导致控制和码流不能兼得，必须在控制的时候暂时断掉码流，控制完后再继续码流。导致控制一次代价特别大。会导致视频流卡顿。
* 在应用层通过libusb直接获取视频流，自行解码，同时通过libusb直接进行控制。
	* 该方法可行，但是自行解码的话，难度也比较大。

以上方法，都有各自的缺点，都不太完美，直到今天，突然看到usb中文网上有一句这样的话：
![[Pasted image 20240802104559.png]]
我好奇，不遵循严格uvc的话，到底是怎么实现的呢，进入libuvc的github页面后，发现：![[Pasted image 20240802104750.png]]
libuvc就是基于libusb实现的！并且集成了jpeglib，完全在应用层实现了uvc视频流传输和控制信息传输，顺便还能解码，完美！

然后我又看了一眼hiki给的linux SDK文件夹，发现SDK文件夹的libraries文件夹里就有libuvc....
原来海康威视根本就没用v4l2直接去控制，而是采用libuvc来进行的控制。
